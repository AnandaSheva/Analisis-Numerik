# -*- coding: utf-8 -*-
"""AnalisisNumerik.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P5M4NW7wgmz0XpLkB_rCQ0_QItR5n1_k

Nama : Ananda Sheva Hidayat
NPM : 2217051096
Kelas : B
"""

import sympy as sp

# Menentukan variabel
x = sp.symbols('x')

# Mendefinisikan fungsi f(x)
f_x = 2*x + 15

# Mengitung turunan
f_prime_x = sp.diff(f_x, x)

# Mencetak turunan
print("Turunan f(x):", f_prime_x)

# Melihat evaluasi turunan untuk beberapa nilai x
x_values = [0, 5]
for x_val in x_values:
    derivative_value = f_prime_x.subs(x, x_val)
    print(f"f'({x_val}) =", derivative_value)

def f(x):
    return x**3 - x**2 - x + 1

a = 2.5
b = 2.6
toleransi = 0.01

while (b - a) / 2 > toleransi:
    midpoint = (a + b) / 2
    if f(midpoint) == 0:
        break
    if f(a) * f(midpoint) < 0:
        b = midpoint
    else:
        a = midpoint

root = (a + b) / 2
print("Akar persamaan di dalam interval [2.6, 2.5] adalah : ", root)

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Matriks koefisien
A = np.array([[5, 0, 0, 1],
              [0, 5, 0, 1],
              [0, 0, 5, -1]])

# Vektor hasil
B = np.array([[5],
              [5],
              [5]])

# Matriks augmented
AB = np.concatenate((A, B), axis=1)

# Eliminasi Gauss
for i in range(0, 3):
    for j in range(i+1, 3):
        ratio = AB[j,i] / AB[i,i]
        AB[j,:] = AB[j,:] - ratio * AB[i,:]

# Substitusi mundur
x = np.zeros((3,1))
x[2] = AB[2,3] / AB[2,2]
x[1] = (AB[1,3] - AB[1,2]*x[2]) / AB[1,1]
x[0] = (AB[0,3] - AB[0,1]*x[1] - AB[0,2]*x[2]) / AB[0,0]

print("Solusi sistem persamaan tiga variabel:")
print("x =", x[0])
print("y =", x[1])
print("z =", x[2])

# Membuat grafik
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

y = np.linspace(-10, 10, 100)
z = np.linspace(-10, 10, 100)
Y, Z = np.meshgrid(y, z)
X = (5 - Y - Z) / 5

ax.plot_surface(Y, Z, X, cmap='viridis')
ax.set_xlabel('y')
ax.set_ylabel('z')
ax.set_zlabel('x')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def f(x):
   return x**3 - x**2 - x + 1
x = np.linspace(2.4, 2.7, 400)
y = f(x)

plt.figure(figsize=(10, 6))
plt.plot(x, y, label='f(x)')
plt.title('Grafik dari f(x) = x^3 - x^2 - x + 1')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np

matrix = np.zeros((3,4))

np.fill_diagonal(matrix, 6)

print(matrix)

import numpy as np

def GaussElim(A,b):
    N = A.shape[0]
    aug_matrix = np.zeros((N,N+1))
    aug_matrix[0:N,0:N] = A.copy()
    aug_matrix[:,N] = b.copy()

    for column in range(0,N):
        for row in range(column+1,N):
            mod_row = aug_matrix[row,:]
            mod_row -= (mod_row[column]/aug_matrix[column,column]*aug_matrix[column,:])
            aug_matrix[row] = mod_row
    return aug_matrix

def BackSub(aug_matrix):
    Nrow, Ncol = aug_matrix.shape
    x = np.zeros(Nrow)

    for row in range(Nrow-1,-1,-1):
        RHS = aug_matrix[row,Nrow]
        for column in range(row+1,Nrow):
            RHS -= x[column]*aug_matrix[row,column]
        x[row] = RHS/aug_matrix[row,row]
    return x

A = np.array([[6, 2, -1], [-2, 6, 3], [0, 3, 6]])
b = np.array([0, 1, 1])

aug_matrix = GaussElim(A, b)
x = BackSub(aug_matrix)

print(x)

def f(x, y):
    return x**2 + 2*y + 3

def runge_kutta_4(x0, y0, h):
    xn = x0
    yn = y0

    for i in range(5):
        k1 = h * f(xn, yn)
        k2 = h * f(xn + h/2, yn + k1/2)
        k3 = h * f(xn + h/2, yn + k2/2)
        k4 = h * f(xn + h, yn + k3)

        yn += (1/6) * (k1 + 2*k2 + 2*k3 + k4)
        xn += h

    return yn

y0 = runge_kutta_4(0, -10, 0.1)
y05_3rd_order_rk = runge_kutta_4(0.5, y0, 0.1)

print("y(0.5) =", y05_3rd_order_rk)
